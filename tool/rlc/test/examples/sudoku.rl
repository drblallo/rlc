# RUN: python %pyscript/solve.py %s -i %stdlib --rlc rlc
import action

# Entities are just like other languages classes. 
# They include fields and methods.
# This is a class that rappresents a sudoku board,
# that is, a 9x9 grid that can contains digits. 
ent Board:
    # The following line is a field declaration.
    # It speficies inside a Board there is a array
    # of 9x9 elements of type BInt<0, 10>, and such 
    # array is named slots.

    # a BInt<min, max> is a bounded integer, 
    # it is used to specify the min and max 
    # value that can placed inside the object. 
    # In this case, it allows to insert into
    # the slots any number between 1 and 9,
    # and uses 0 as the value to rapresent
    # emtpyness
    BInt<0, 10>[9][9] slots

    # this is a member function declaration
    # it declares a function called is_full,
    # with return type Bool, and zero 
    # arguments
    # returns true when all the slots in the 
    # game have been filled with a number.
    fun is_full() -> Bool:
      return self.count_empty() == 0

    # count_empty returns the number of slots
    # that have not yet been filled with a 
    # number
    fun count_empty() -> Int:
      let empty = 0
      let i = 0
      while i != 9:
        let y = 0
        while y != 9:
          if self.slots[y][i].value == 0:
            empty = empty + 1 
          y = y + 1
        i = i + 1
      return empty

    # returns true if the 3x3 region of the board
    # that contains a given cell does not contain
    # any cell with the given number.
    fun region_is_missing(Int row, Int column, Int number) -> Bool:
      let i = (row / 3)
      while i != (row / 3) + 3:
        let y = (column / 3)
        while y != (column / 3) + 3:
          if self.slots[y][i].value == number:
            return false
          y = y + 1
        i = i + 1
      return true

    # returns true in the given column
    # does not contain the given number
    fun column_is_missing(Int column, Int number) -> Bool:
      let i = 0
      while i != 9:
        if self.slots[column][i].value == number:
            return false
        i = i + 1
      return true

    # returns true in the given row
    # does not contain the given number
    fun row_is_missing(Int row, Int number) -> Bool:
      let i = 0
      while i != 9:
        if self.slots[i][row].value == number:
            return false
        i = i + 1
      return true

    # returns true if marking the given cell
    # with the given number is valid
    fun can_mark(Int row, Int column, Int number) -> Bool:
        return self.row_is_missing(row, number) and self.column_is_missing(column, number) and self.region_is_missing(row, column, number) and self.slots[column][row] == 0

    # returns true if there is at least a cell
    # that can be filled a number
    fun at_least_one_action_is_possible() -> Bool:
      let i = 0
      while i != 9:
        let y = 0
        while y != 9:
          let val = 1
          while val != 10:
            if self.can_mark(i, y, val):
              return true
            val = val + 1
          y = y + 1
        i = i + 1
      return false

# The next line of code introduces a Action Function. 
# Action Functions are pieces of codes that are written
# the same way functions would, but they instead express
# a interactive procedure
#
# This action function is called play, and it encodes
# the rules of sudoku. 
# This action function is called play because the machine
# learning components will look for a function called this 
# way. The return type is called Game for the same reason.
#
# The game is composed of two parts, the first is when a 
# random sudoku board is generated by writing random 
# numbers are written into it. The second part is the part
# where the user tries to solve the game.
act play() -> Game:
    # This is a variable declaration. It allocates a local 
    # variable named board, of type Board. The variable is
    # introduced by the keyword frm, which specifies that
    # the variable is of interest not only to this function,
    # to the users of sudoku in general. This is of course 
    # the case, since players need to look inside the sudoku
    # board to decide what to do.
    frm board : Board
    frm i = 0
    frm game_began = false
    while i != 20:
        # The following line introduces a action statement.
        # Actions statements are how 
        act random_mark(BInt<0, 9> x, BInt<0, 9> y, BInt<1, 10> number) {
            board.can_mark(x.value, y.value, number.value)
        }
        board.slots[y.value][x.value] = number.value
        i = i + 1

    game_began = true
    while !board.is_full() and board.at_least_one_action_is_possible():
        act mark(BInt<0, 9> x, BInt<0, 9> y, BInt<1, 10> number) {
            board.can_mark(x.value, y.value, number.value) 
        }
        board.slots[y.value][x.value] = number.value

fun get_current_player(Game g) -> Int:
    if g.is_done():
        return -4
    if !g.game_began:
        return -1
    
    return 0

fun get_num_players() -> Int:
    return 1

fun max_game_lenght() -> Int:
    return 200 

fun score(Game g, Int player_id) ->  Float:
    return 1.0 - float(g.board.count_empty()) / 81.0

fun main() -> Int:
    return 0

fun gen_printer_parser():
    let state : Game
    let any_action :  AnyGameAction
    gen_python_methods(state, any_action)

